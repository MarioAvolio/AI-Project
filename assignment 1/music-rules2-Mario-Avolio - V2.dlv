% we can use --no-facts to avoid facts 
% Small Music KB Example
% n Let’s build a small KB in the music domain
% n Let’s define the following unary predicates
% ¨artist(X): X is an artist
% ¨band(X): X is a band
% ¨singer(X): X is a singer
% ¨musician(X): X is a musician
% ¨music_work(X): X is a music work (a single,
% an LP)
% ¨genre(X): X is a genre 


% Let’s build a small KB in the music domain
% n Let’s define the following binary predicates
% ¨ artist_of(X,Y): X is the artist of the Y music work
% ¨ member_of(X,Y): X is member of the band Y
% ¨ music_genre(X,Y): Y is the genre of the music
% work X
% ¨ subgenre(X,Y): X is subgenre of Y
% ¨ plays_genre(X,Y): X plays music of genre Y



% this is an example ONLY for a fast generation of facts
artist(1..10). band(1..3). singer(1..10). musician(1..10). music_work(1..10). genre(1..20). % facts
artist_of(X,Y) | noArtist_of(X,Y) :- artist(X), music_work(Y). % guess

% check
:- artist(X), #count{Y,X : artist_of(X,Y)} < 1. % an artist can not have less than 1 music work
:- music_work(Y), #count{X,Y : artist_of(X,Y)} > 2. % a music work can not have more than 2 (only for example) artists




member_of(X, Y) | noMmember_of(X,Y) :- artist(X), band(Y). %guess
%check
:- artist(X), #count{Y,X : member_of(X,Y)} > 1. % an artist can have (for example) only a single band.
% the size of a band should be between 3 and 5 members.
:- band(Y), #count{X,Y : member_of(X,Y)} = K, K>5. 
:- band(Y), #count{X,Y : member_of(X,Y)} = K, K<2.



%guess
music_genre(X,Y) | noMusic_genre(X,Y) :- music_work(X), genre(Y).
%check
:- music_work(X), #count{Y,X : music_genre(X,Y)} < 1. % a music work should have at least one genre
:- music_work(X), #count{Y,X : music_genre(X,Y)} > 2. % a music work should have at most 2 genres
% optimize
:~ genre(Y), #count{X,Y : music_genre(X,Y)} = K. [1@K, Y] % avoid to use the same genre for all music works


subgenre(X,Y) | noSubgenre(X,Y) :- genre(X), genre(Y), X < Y. % X<Y to optimize
:- subgenre(X,Y), X==Y. % X cannot be a subgenre of itself
:- genre(Y), #count{X,Y : subgenre(X,Y)} > 3. % a genre cannot have more than 3 subgenres (for example)
:- genre(X), #count{Y,X : subgenre(X,Y)} > 1. % a subgenre cannot have more than 1 genre


plays_genre(X,Y) | noPlays_genre(X,Y) :- musician(X), genre(Y).
:- musician(X), #count{Y,X : plays_genre(X,Y)} > 3. % a musician cannot play more than 3 genre (only for example).
:- genre(Y), #count{X,Y : plays_genre(X,Y)} > 4. % a genre cannot be played more than 4 musicians (onyl for example).


%Cautious reasoning: the answer must be inferred in every answer set
% Brave reasoning: the answer must be inferred in at least one answer set
% - dlv.bin tweety2.txt Tweety2-query.txt –brave
% -FB, -brave	Brave query answering
% -FC, -cautious	Cautious query answering


% DLV (Disjunctive Logic Programming with Defaults) is a popular non-monotonic logic programming system used for knowledge representation and reasoning. In DLV, there are two main types of reasoning strategies: Brave Reasoning and Cautious Reasoning. Let's explore the differences between them with examples:

% 1. **Brave Reasoning**:
%    - Brave reasoning, also known as skeptical reasoning, produces the most optimistic conclusions based on the available information.
%    - It assumes that all the defaults and rules are applicable unless there is explicit evidence to the contrary.
%    - It derives conclusions that can be justified by the available knowledge but may not necessarily be true in all possible scenarios.
%    - Brave reasoning aims to maximize the set of conclusions.
   
%    **Example**:
%    Consider a DLV program with the following rules:
%    ```
%    p(X) :- not q(X).
%    q(a).
%    ```
%    Using Brave reasoning, we can conclude that `p(a)` is true because there is no explicit evidence (no `not p(a)`) to contradict it.

% 2. **Cautious Reasoning**:
%    - Cautious reasoning, also known as skeptical reasoning, is more conservative and only derives conclusions that are guaranteed to be true regardless of unobservable facts.
%    - It considers only those conclusions that can be justified not only by the available information but also in all possible scenarios.
%    - Cautious reasoning aims to minimize the set of conclusions.
   
%    **Example**:
%    Using the same DLV program as above, Cautious reasoning would not conclude anything because there is not enough evidence to guarantee that `p(a)` is true in all scenarios. Cautious reasoning would require explicit evidence like `p(a)` in the rules or facts.

% In summary, Brave reasoning derives conclusions based on available evidence, while Cautious reasoning is more conservative and only derives conclusions that are guaranteed to be true in all possible scenarios, requiring stronger evidence. The choice between these reasoning strategies depends on the specific problem and the level of certainty required in the conclusions.

% Keep in mind that DLV is a complex knowledge representation system, and the behavior of reasoning may vary depending on the specific DLV program and its rules. The examples provided here are simplified for illustrative purposes.